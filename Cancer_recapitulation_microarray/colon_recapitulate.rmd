---
title: "GSE Analysis"
author: "Tim Nieuwenhuis"
date: "12/3/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggforce)
library(tidyverse)
library(reshape2)
```

```{r}
## Figure out these pvalues
tissue_temp <- "colon"

# Version info: R 3.2.3, Biobase 2.30.0, GEOquery 2.40.0, limma 3.26.8
################################################################
#   Differential expression analysis with limma
library(GEOquery)
library(limma)
library(umap)

# load series and platform data from GEO

gset <- getGEO("GSE44076", GSEMatrix =TRUE, AnnotGPL=FALSE)
if (length(gset) > 1) idx <- grep("GPL13667", attr(gset, "names")) else idx <- 1
gset <- gset[[idx]]
features <- fData(gset)
samples <- pData(gset)
```

So according to the data set the data has been preprocessed as follows:
The Robust Multi-array Average (RMA) algorithm was used for data normalization through R and Bioconductor.

```{r}
## Getting a sense of the data structure
hist(exprs(gset))
hist(log2(exprs(gset)))

## Either way the data is bimodal

## Getting a sense of what data to include as batch
head(samples)
unique(samples$platform_id)
unique(samples$channel_count)
unique(samples$taxid_ch1)
unique(samples$`sample type:ch1`)

### Note, this experiment used 96 well plates, but gave not batch numbers :-/

## Select useful batch elements for limma
design_dat <-   select(samples,
                   age = `age:ch1`,
                   gender = `gender:ch1`,
                   sample = `sample type:ch1`,
                   indiv = `individual id:ch1`) %>%
    mutate(age = as.numeric(age))
## Making the design matrix
design <- model.matrix(~ 0 + sample + age + gender, design_dat)

fit <- lmFit(exprs(gset), design)
#vfit <- contrasts.fit(vfit, contrasts=contr.matrix)
## Making contrasts, basically allows me to see differences between the data types
contr.matrix <- makeContrasts(
    CancervsAdjacent = sampleTumor - sampleNormal,
    AdjacentvsNormal = sampleMucosa - sampleNormal,
    CancervsNormal  = sampleTumor - sampleMucosa,
   levels = colnames(design))
#contr.matrix
#Fit the contrasts
fit <- contrasts.fit(fit, contrasts=contr.matrix)
## Comput statistics for fitted model
efit <- eBayes(fit)


## See hgow many up or downregulated genes there are, imo their are to many
## But this appears to be the final data the website is reporting
summary(decideTests(efit))



# assumption is that most genes are not differentially expressed.
tT2 <- topTable(efit, adjust="holm", sort.by="B", number=Inf)
hist(tT2$adj.P.Val, col = "grey", border = "white", xlab = "P-adj",
  ylab = "Number of genes", main = "P-adj value distribution")

hist(tT2$P.Value, col = "grey", border = "white", xlab = "P-adj",
  ylab = "Number of genes", main = "P-un-adj value distribution")

## This section shows that the assumnption in this context fails to hold
## There are far more significant genes than their should be, but again
## this appears to be the data the website is based on


## Below I'm getting a sense of how to interact with the data before making a
## proper function


cov_pval = cbind(efit$coefficients, efit$p.value)
colnames(cov_pval) <- c(paste0(colnames(cov_pval)[1:3], "_cov"),
                        paste0(colnames(cov_pval)[1:3], "_pval"))

cov_pval<- as.data.frame(cov_pval)

cov_pval$genes <- features$`Gene Symbol`




filter(cov_pval, genes %in% c("COL10A1", "MMP11", "COL11A1", "COMP", "SPP1"))


##  Generating a function to explore limma data with genes names post limma
## analysis
head(efit)

gene <- "MMP1"
fit_vals <- efit

post_limma_gene <- function(fit_vals, gene, sig_t_f = FALSE){
    ### The purpose of this function is to pull gene data from the output of
    ### limma() post eBayes(). This function specifically will pull gene data
    ### on covariates and pvalues along with adjusting said pvalues. This 
    ### function is made to be use with lapply() and is nested in the next fucntion
    
    ## Bind covariates and pvals together
    cov_pval <- cbind(fit_vals$coefficients, fit_vals$p.value)
    ## Make sure names fit covariates and pvals along with making data frane
    colnames(cov_pval) <- c(paste0(colnames(cov_pval)[1:3], "_cov"),
                        paste0(colnames(cov_pval)[1:3], "_pval"))
    res_dat  <- rownames_to_column(as.data.frame(cov_pval), var = "gene_ids")
    ## Filter features down to gene of interest
    sub_feat <- features[features$`Gene Symbol` %in% gene,]
    filt_res <- res_dat[res_dat$gene_ids %in% sub_feat$ID,]
    ## Geberate final data frame by adjusing pvalues and adding gene symbol
    ## as a column
    final_res <- filt_res %>%
        mutate(across(contains("pval"),
                      .fns = list(adj = ~p.adjust(., method = "holm",
                                                          n = nrow(cov_pval) * ncol(cov_pval)/3))),
               gene_symbol = gene) %>%
        select(gene_ids, gene_symbol, everything())
    ## If you want the actual adjusted values the coe ends
    ## Else the adjusted values are turned into TRUE and FALSE to summarize results
    if (sig_t_f == FALSE) {
        return(final_res)
    }
    final_res %>% mutate(across(contains("pval_adj"), .fns = ~ifelse(. <= .05, TRUE, FALSE)))
}
## Read in the gene data
all_tcga_ranks <- read.csv("data_out/all_tcga_current_sum_ranks.csv") %>% arrange(desc(sum_ranks))

## Make gene lists
top_genes <- head(all_tcga_ranks$genes, 10)
bot_genes <- tail(all_tcga_ranks$genes, 10)


## Below I start testing out possible analysis methods before I make it a data.frame
post_limma_gene(efit, "WISP2", sig_t_f = T)

top_res <- (lapply(top_genes, function(x){post_limma_gene(efit, x, sig_t_f = T)}))
do.call(rbind, top_res)

bot_res_list <- (lapply(bot_genes, function(x){post_limma_gene(efit, x, sig_t_f = T)}))
result_bot  <- do.call(rbind, bot_res_list) %>% mutate(result_type = case_when(
            CancervsAdjacent_pval_adj == T &
                AdjacentvsNormal_pval_adj == T &
                CancervsNormal_pval_adj == T ~ "All Sig",
                CancervsAdjacent_pval_adj == F &
                AdjacentvsNormal_pval_adj == F &
                CancervsNormal_pval_adj == F ~ "No Sig",
                CancervsAdjacent_pval_adj == F &
                AdjacentvsNormal_pval_adj == F &
                CancervsNormal_pval_adj == T ~ "Norm v cancer sig",
                CancervsAdjacent_pval_adj == T &
                AdjacentvsNormal_pval_adj == F &
                CancervsNormal_pval_adj == F ~ "Adj v cancer sig",
            CancervsAdjacent_pval_adj == T &
                AdjacentvsNormal_pval_adj == F &
                CancervsNormal_pval_adj == T ~ "Normals sig v cancer",
                AdjacentvsNormal_pval_adj == T  ~ "Norm mismatch"
            
        )) %>% select(gene_ids, gene_symbol, result_type, everything())
```


```{r}
gene_list <- top_genes
gene_list <- bot_genes
fit_dat <- efit
table_version = TRUE

## Generate summary results functionf or gene lists

summ_gene_list <- function(gene_list, fit_dat, table_version =  FALSE, up_o_down = NA){
    ### This code is used to summarize the output of the limma with a list
    ### of genes into a very simplified table or a normal data.frame
    
    ## Run lapply to make a list of results from post_limma_gene
    temp_list <- lapply(gene_list, function(x){post_limma_gene(fit_dat, x, sig_t_f = T)})
    ## Using case_when to generalize the results for the various oligos per gene
    temp_res <-  do.call(rbind, temp_list) %>% mutate(result_type = case_when(
            CancervsAdjacent_pval_adj == T &
                AdjacentvsNormal_pval_adj == T &
                CancervsNormal_pval_adj == T ~ "All Sig",
                CancervsAdjacent_pval_adj == F &
                AdjacentvsNormal_pval_adj == F &
                CancervsNormal_pval_adj == F ~ "No Sig",
                CancervsAdjacent_pval_adj == F &
                AdjacentvsNormal_pval_adj == F &
                CancervsNormal_pval_adj == T ~ "Normal",
                CancervsAdjacent_pval_adj == T &
                AdjacentvsNormal_pval_adj == F &
                CancervsNormal_pval_adj == F ~ "Paratumor",
            CancervsAdjacent_pval_adj == T &
                AdjacentvsNormal_pval_adj == F &
                CancervsNormal_pval_adj == T ~ "Combo",
                AdjacentvsNormal_pval_adj == T  ~ "Norm mismatch"
            
        )) %>% select(gene_ids, gene_symbol, result_type, everything())
    ## Make it a table orn not
    if (table_version == FALSE) {
        return(temp_res)
    }
    table_return <- as.matrix(table(temp_res$gene_symbol, temp_res$result_type))
    #table_return[table_return>0] <- 1
    table_return <- rbind(table_return, colSums(table_return))
    rownames(table_return)[nrow(table_return)] <- "Sums" 
    return(table_return)
}

#table(result_bot$gene_symbol, result_bot$result_type)

top_tab <- summ_gene_list(top_genes,fit_dat = efit, table_version = T)
top_tab
bot_tab <- summ_gene_list(bot_genes,fit_dat = efit, table_version = T)
bot_tab

dat<- bot_tab
pos_o_neg <- "positive"
combo_o_deep_filter <- function(dat){
  # oppo <- ifelse(pos_o_neg == "positive", "negative", "positive")
   if ("Normal" %in% colnames(dat)) {
    sigs <-dat[-nrow(dat),-which(colnames(dat) %in% c("No Sig")), drop = FALSE]
     no_sigs <- dat[-nrow(dat), "No Sig", drop = FALSE]
     ind <- rowSums(sigs) > rowSums(no_sigs)
   } else {
     sigs <-dat[-nrow(dat),-which(colnames(dat) %in% c("No Sig")), drop = FALSE]
     no_sigs <- dat[-nrow(dat), "No Sig", drop = FALSE]
     ind <- rowSums(sigs) > rowSums(no_sigs)
   }
  
  dat <- dat[c(ind, TRUE),]
  return(dat)
}

top_sig <- combo_o_deep_filter(top_tab)
bot_sig <- combo_o_deep_filter(bot_tab)


temps <- rbind(nrow(top_sig) - 1, nrow(bot_sig) - 1)
rownames(temps) <- c("Sig Top", "Sig Bot")
colnames(temps) <- tissue_temp
if (file.exists("data_out/recapitulate_table.csv")) {
  recap_temp <- read.csv("data_out/recapitulate_table.csv",row.names = 1)
  recap_temp[[tissue_temp]] <- temps[,1]
  write.csv(recap_temp,"data_out/recapitulate_table.csv",row.names = T)
} else{
  write.csv(temps,"data_out/recapitulate_table.csv")
}


```


Quality check GSET
```{r}

melt_gset <- melt(exprs(gset))
ggplot(melt_gset,aes(x=value, color=Var2)) + geom_density(alpha=0.25) +
  theme(legend.position = "none")

melt_gset_log <- melt(log2(exprs(gset)))
ggplot(melt_gset_log,aes(x=value, color=Var2)) + geom_density(alpha=0.25) +
  theme(legend.position = "none")

gset_gene_checker <- function(gset_dat, gene){
    
    ind <- fData(gset_dat)$`Gene Symbol` %in% gene
    sub_gset <- ind
    gset_sub <- gset_dat[ind,]
    exprs_sub <- exprs(gset_sub)
    exprs_sub_t <- as.data.frame(t(exprs_sub)) %>%
        rownames_to_column(var = "sample_id")
    exprs_sub_t["sample_type"] <- pData(gset_sub)$'sample type:ch1'
    
    exprs_melt <- melt(exprs_sub_t,id.vars = c("sample_id", "sample_type"))
    ggplot(exprs_melt, aes(x = sample_type, y= value)) +
        geom_sina() +
        facet_grid(~variable) +
        theme_classic() +
        labs(title = paste0("Comparison for gene ", gene))
}

gene <- "MMP1"
ind <- fData(gset)$`Gene Symbol` %in% gene
sub_gset <- ind
gset_sub <- gset[ind,]
exprs_sub <- exprs(gset_sub)
exprs_sub_t <- as.data.frame(t(exprs_sub)) %>%
    rownames_to_column(var = "sample_id")
exprs_sub_t["sample_type"] <- pData(gset_sub)$'sample type:ch1'

exprs_melt <- melt(exprs_sub_t,id.vars = c("sample_id", "sample_type"))
ggplot(exprs_melt, aes(x = sample_type, y= value)) +
    geom_sina() +
    facet_grid(~variable) +
    theme_classic() +
    labs(title = paste0("Comparison for gene ", gene))
    
    
gset_gene_checker(gset, "OGN")    
```


Gene Sig Checker
```{r}

```





The rest of the analysis
```{r}
# make proper column names to match toptable 
fvarLabels(gset) <- make.names(fvarLabels(gset))

# group membership for all samples
gsms <- paste0("22222222222222222222222222222222222222222222222222",
        "11111111111111111111111111111111111111111111111111",
        "11111111111111111111111111111111111111111111111100",
        "00000000000000000000000000000000000000000000000000",
        "0000000000000000000000000000000000000000000000")
sml <- strsplit(gsms, split="")[[1]]

# log2 transformation
ex <- exprs(gset)
qx <- as.numeric(quantile(ex, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
LogC <- (qx[5] > 100) ||
          (qx[6]-qx[1] > 50 && qx[2] > 0)
if (LogC) { ex[which(ex <= 0)] <- NaN
  exprs(gset) <- log2(ex) }

# assign samples to groups and set up design matrix
gs <- factor(sml)
groups <- make.names(c("Cancer","adjacent normal","healthy normal"))
levels(gs) <- groups
gset$group <- gs
design <- model.matrix(~group + 0, gset)
colnames(design) <- levels(gs)

fit <- lmFit(gset, design)  # fit linear model

# set up contrasts of interest and recalculate model coefficients
cts <- paste(groups, c(tail(groups, -1), head(groups, 1)), sep="-")
cont.matrix <- makeContrasts(contrasts=cts, levels=design)
fit2 <- contrasts.fit(fit, cont.matrix)

# compute statistics and table of top significant genes
fit2 <- eBayes(fit2, 0.01)
tT <- topTable(fit2, adjust="fdr", sort.by="B", number=250)

tT <- subset(tT, select=c("ID","adj.P.Val","P.Value","F","Gene.Symbol","GB_LIST","SPOT_ID"))
write.table(tT, file=stdout(), row.names=F, sep="\t")

# Visualize and quality control test results.
# Build histogram of P-values for all genes. Normal test
# assumption is that most genes are not differentially expressed.
tT2 <- topTable(fit2, adjust="fdr", sort.by="B", number=Inf)
hist(tT2$adj.P.Val, col = "grey", border = "white", xlab = "P-adj",
  ylab = "Number of genes", main = "P-adj value distribution")

# summarize test results as "up", "down" or "not expressed"
dT <- decideTests(fit2, adjust.method="fdr", p.value=0.05)

# Venn diagram of results
vennDiagram(dT, circle.col=palette())

# create Q-Q plot for t-statistic
t.good <- which(!is.na(fit2$F)) # filter out bad probes
qqt(fit2$t[t.good], fit2$df.total[t.good], main="Moderated t statistic")

# volcano plot (log P-value vs log fold change)
colnames(fit2) # list contrast names
ct <- 1        # choose contrast of interest
volcanoplot(fit2, coef=ct, main=colnames(fit2)[ct], pch=20,
  highlight=length(which(dT[,ct]!=0)), names=rep('+', nrow(fit2)))

# MD plot (log fold change vs mean log expression)
# highlight statistically significant (p-adj < 0.05) probes
plotMD(fit2, column=ct, status=dT[,ct], legend=F, pch=20, cex=1)
abline(h=0)

################################################################
# General expression data analysis
ex <- exprs(gset)

# box-and-whisker plot
dev.new(width=3+ncol(gset)/6, height=5)
ord <- order(gs)  # order samples by group
palette(c("#1B9E77", "#7570B3", "#E7298A", "#E6AB02", "#D95F02",
          "#66A61E", "#A6761D", "#B32424", "#B324B3", "#666666"))
par(mar=c(7,4,2,1))
title <- paste ("GSE44076", "/", annotation(gset), sep ="")
boxplot(ex[,ord], boxwex=0.6, notch=T, main=title, outline=FALSE, las=2, col=gs[ord])
legend("topleft", groups, fill=palette(), bty="n")
dev.off()

# expression value distribution
par(mar=c(4,4,2,1))
title <- paste ("GSE44076", "/", annotation(gset), " value distribution", sep ="")
plotDensities(ex, group=gs, main=title, legend ="topright")

# UMAP plot (dimensionality reduction)
ex <- na.omit(ex) # eliminate rows with NAs
ex <- ex[!duplicated(ex), ]  # remove duplicates
ump <- umap(t(ex), n_neighbors = 15, random_state = 123)
par(mar=c(3,3,2,6), xpd=TRUE)
plot(ump$layout, main="UMAP plot, nbrs=15", xlab="", ylab="", col=gs, pch=20, cex=1.5)
legend("topright", inset=c(-0.15,0), legend=levels(gs), pch=20,
col=1:nlevels(gs), title="Group", pt.cex=1.5)
library("maptools")  # point labels without overlaps
pointLabel(ump$layout, labels = rownames(ump$layout), method="SANN", cex=0.6)

# mean-variance trend, helps to see if precision weights are needed
plotSA(fit2, main="Mean variance trend, GSE44076")
```

